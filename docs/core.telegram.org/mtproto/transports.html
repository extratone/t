<!DOCTYPE html>
<html class="">
  <head>
    <meta charset="utf-8">
    <title>Transports</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta property="description" content="Enables the delivery of encrypted containers together with the external header (hereinafter, Payload) from client to server…">
    <meta property="og:title" content="Transports">
    <meta property="og:image" content="beaf97b9951c081b35">
    <meta property="og:description" content="Enables the delivery of encrypted containers together with the external header (hereinafter, Payload) from client to server…">
    <link rel="shortcut icon" href="/favicon.ico?4" type="image/x-icon" />

    <link href="/css/bootstrap.min.css?3" rel="stylesheet">
    
    <link href="/css/telegram.css?212" rel="stylesheet" media="screen">
    <style>
    </style>
  </head>
  <body class="preload">
    <div class="dev_page_wrap">
      <div class="dev_page_head navbar navbar-static-top navbar-tg">
        <div class="navbar-inner">
          <div class="container clearfix">
            <ul class="nav navbar-nav navbar-right hidden-xs"><li class="navbar-twitter"><a href="https://twitter.com/telegram" target="_blank" data-track="Follow/Twitter" onclick="trackDlClick(this, event)"><i class="icon icon-twitter"></i><span> Twitter</span></a></li></ul>
            <ul class="nav navbar-nav">
              <li><a href="//telegram.org/">Home</a></li>
<li class="hidden-xs"><a href="//telegram.org/faq">FAQ</a></li>
<li class="hidden-xs"><a href="//telegram.org/apps">Apps</a></li>
<li class=""><a href="/api">API</a></li>
<li class="active"><a href="/mtproto">Protocol</a></li>
<li class=""><a href="/schema">Schema</a></li>
            </ul>
          </div>
        </div>
      </div>
      <div class="container clearfix">
        <div class="dev_page">
          <div id="dev_page_content_wrap" class=" ">
  <div class="dev_page_bread_crumbs"><ul class="breadcrumb clearfix"><li><a  href="/mtproto" >Mobile Protocol</a></li><i class="icon icon-breadcrumb-divider"></i><li><a  href="/mtproto/transports" >Transports</a></li></ul></div>
  <h1 id="dev_page_title">Transports</h1>
  
  <div id="dev_page_content"><!-- scroll_nav -->

<p>Enables the delivery of encrypted containers together with the external header (hereinafter, <em>Payload</em>) from client to server and back. 
Multiple transport protocols are defined:</p>
<ul>
<li><a href="#tcp">TCP</a></li>
<li><a href="#websocket">Websocket</a></li>
<li><a href="#websocket-over-https">Websocket over HTTPS</a></li>
<li><a href="#http">HTTP</a></li>
<li><a href="#https">HTTPS</a></li>
</ul>
<p>The URI format for connecting to the websocket and HTTP endpoints is the following:</p>
<ul>
<li><a href="#uri-format">URI format</a><ul>
<li><a href="#tls-uri-format">TLS URI format</a></li>
</ul>
</li>
</ul>
<h3><a class="anchor" href="#tcp" id="tcp" name="tcp"><i class="anchor-icon"></i></a>TCP</h3>
<p>The TCP transport is implemented simply by sending the payloads generated by the chosen <a href="/mtproto/mtproto-transports">MTProto transport</a> over a plain TCP socket on ports 80, 443, 5222 or other (a different port number may be returend by <a href="https://core.telegram.org/method/help.getConfig">help.getConfig</a>).</p>
<p>Framing is managed by the chosen <a href="/mtproto/mtproto-transports">MTProto transport protocol</a>.</p>
<p>There are no implicit acknowledgments for the TCP transport: all messages must be acknowledged explicitly. Most frequently, acknowledgments are placed in a container with the next query or response if it is transmitted in short order. For example, this is almost always the case for client messages containing RPC queries: the acknowledgment normally arrives with the RPC response.</p>
<h3><a class="anchor" href="#websocket" id="websocket" name="websocket"><i class="anchor-icon"></i></a>Websocket</h3>
<p>Implementation of the websocket transport is pretty much the same as with TCP: a <a href="https://en.wikipedia.org/wiki/WebSocket">websocket</a> connection is established to the chosen MTProto server over port 80 using the specified <a href="#uri-format">URI format</a>.  </p>
<p>Framing of payloads is still managed by the chosen <a href="/mtproto/mtproto-transports">MTProto transport protocol</a>, not by websocket messages: the length of MTProto payloads is defined by the <a href="/mtproto/mtproto-transports">MTProto transport protocol</a>, not by the length of the single websocket messages.
This simply means that all data received and sent through websocket messages is to be treated as a single duplex stream of bytes, just like with TCP.</p>
<p>When using the websocket transport, <a href="/mtproto/mtproto-transports#transport-obfuscation">transport obfuscation is required</a>.
Transport errors are transmitted <a href="/mtproto/mtproto-transports#transport-errors">the usual way</a>, as with TCP.
The close code of websockets will <strong>always</strong> be <code>1000</code> (normal closure), regardless of the actual exit status.
In all cases, the description string will be a decimal encoded real error code (which may be forward/back-padded with whitespaces for constant length) and can be safely ignored.</p>
<p>Example implementation: <a href="https://github.com/danog/MadelineProto/blob/master/src/danog/MadelineProto/Stream/Transport/WsStream.php">MadelineProto</a>.</p>
<h3><a class="anchor" href="#websocket-over-https" id="websocket-over-https" name="websocket-over-https"><i class="anchor-icon"></i></a>Websocket over HTTPS</h3>
<p>To establish a websocket connection over HTTPS, simply use the <a href="#tls-uri-format">TLS URI format</a>.
The rest is the same as with <a href="#websocket">plain websockets</a>.</p>
<h3><a class="anchor" href="#http" id="http" name="http"><i class="anchor-icon"></i></a>HTTP</h3>
<p>Note: when implementing browser clients, <a href="#websocket">websocket transport</a> is recommended instead of HTTP, thanks to its full-duplex stream logic similar to TCP's; this removes the need for <a href="https://core.telegram.org/mtproto/service_messages#http-wait-long-poll">HTTP long polling</a> and eventual delays while relaying RPC replies.</p>
<p>Implemented over HTTP/1.1 (with keepalive) running over the traditional TCP Port 80.
<a href="#https">HTTPS can also be used</a>.</p>
<p>Message framing is <strong>not</strong> managed by <a href="/mtproto/mtproto-transports">MTProto transport protocols</a>; it is instead handled by the HTTP protocol itself.
Transport errors are also <strong>not</strong> transmitted <a href="/mtproto/mtproto-transports#transport-errors">the usual way</a>, instead they are simply returned as normal HTTP status codes.</p>
<p>An HTTP connection is attached to a session (or rather, to session + key identifier) specified in the most recent user query received; normally, the session is the same in all queries, but crafty HTTP proxies may corrupt that. A server may not return a message into an HTTP connection unless it belongs to the same session, and unless it is the server’s turn (an HTTP request had been received from the client to which a response has not been sent yet).</p>
<p>The overall arrangement is as follows. The client opens one or more keepalive HTTP or HTTPS connections to the server. If one or more messages need to be sent, they are made into a <em>payload</em> which is followed by a POST request to the URL/api to which the payload is transmitted as data. In addition, <code>Content-Length</code>, <code>Keepalive</code>, and <code>Host</code> are valid HTTP headers.</p>
<p>Having received the query, the server may either wait a little while (if the query requires a response following a short timeout) or immediately return a dummy response (only acknowledging the receipt of the container). In any case, the response may contain any number of messages. The server may at the same time send out any other messages it might be holding for the session.</p>
<p>In addition, there exists a special <a href="https://core.telegram.org/mtproto/service_messages#http-wait-long-poll">long poll RPC query</a> (valid for HTTP connections only) which transmits maximum timeout <em>T</em>. If the server has messages for the session, they are returned immediately; otherwise, a wait state is entered until such time as the server has a message for the client or <em>T</em> seconds have elapsed. If no events occur in the span of <em>T</em> seconds, a dummy response is returned (special message).</p>
<p>If a server needs to send a message to a client, it checks for an HTTP connection that belongs to the required session and is in the “answering an HTTP request” state (including long poll) whereupon the message is added to the response container for the connection and sent to the user. In a typical case, there is some additional wait time (50 milliseconds) against the eventuality that the server will soon have more messages for the session.</p>
<p>If no suitable HTTP connection is available, the messages are placed in the current session’s send queue. However, they find their way there anyway until receipt is explicitly confirmed by the client. For all protocols, the client must return an explicit acknowledgment within a reasonable time (it can be added to a container for the following request).</p>
<p><strong><em>Important</em></strong>: if the acknowledgment fails to arrive on time, the message can be resent (possibly, in a different container). The parties must autonomously be ready for this and must store the identifiers of the most recent messages received (and ignore such duplicates rather than repeat actions). In order not to have the identifiers stored forever, there exist special <em>garbage collection</em> messages that take advantage of message identifier monotonicity.</p>
<p>If the send queue overflows or if messages stay in the queue for over 10 minutes, the server forgets them. This may happen even faster, if the server is running out of buffer space (for example, because of serious network issues resulting in a large number of connections becoming severed).</p>
<h3><a class="anchor" href="#https" id="https" name="https"><i class="anchor-icon"></i></a>HTTPS</h3>
<p>To establish a connection over HTTPS, simply use the <a href="#tls-uri-format">TLS URI format</a>.
The rest is the same as with <a href="#http">plain HTTP</a>.</p>
<h3><a class="anchor" href="#uri-format" id="uri-format" name="uri-format"><i class="anchor-icon"></i></a>URI format</h3>
<p>The URI format that must be used when connecting to the plain websocket and HTTP endpoints is the following: </p>
<pre><code>http://X.X.X.X:80/api(w)(s)</code></pre>
<pre><code>http://(name)(-1).web.telegram.org:80/api(w)(s)(_test)</code></pre>
<p>The <code>w</code> flag is added when CORS headers are required in order to connect from a browser.<br>
The <code>s</code> flag enables the websocket API.<br>
The <code>name</code> placeholder in the domain version specifies the DC ID to connect to:  </p>
<ul>
<li><code>pluto</code> =&gt; DC 1</li>
<li><code>venus</code> =&gt; DC 2</li>
<li><code>aurora</code> =&gt; DC 3</li>
<li><code>vesta</code> =&gt; DC 4</li>
<li><code>flora</code> =&gt; DC 5</li>
</ul>
<p><code>-1</code> can be appended to the DC name to raise the maximum limit of simultaneous requests per hostname.<br>
The <code>_test</code> flag, when connecting to the domain version of the URL, specifies that connection to the test DCs must be made, instead.  </p>
<h4><a class="anchor" href="#tls-uri-format" id="tls-uri-format" name="tls-uri-format"><i class="anchor-icon"></i></a>TLS URI format</h4>
<p>When connecting to the HTTPS and WSS endpoints, only the domain name URI can be used over port 443:</p>
<pre><code>https://(name)(-1).web.telegram.org:443/api(w)(s)(_test)</code></pre>
<p>See the <a href="#uri-format">URI format</a> for an explanation of the placeholders.</p>
<p>Example implementations: <a href="https://github.com/tdlib/td/blob/56163c2460a65afc4db2c57ece576b8c38ea194b/td/telegram/net/ConnectionCreator.cpp">tdlib</a>, <a href="https://github.com/danog/MadelineProto/blob/master/src/danog/MadelineProto/DataCenter.php">MadelineProto</a> (client side), <a href="https://github.com/TelegramMessenger/MTProxy/blob/28f5b17eef2f50d768c4f010f8a4fc149254550a/mtproto/mtproto-proxy.c">MTProxy</a> (server side).</p></div>
  
</div>
          
        </div>
      </div>
      <div class="footer_wrap">
  <div class="footer_columns_wrap footer_desktop">
    <div class="footer_column footer_column_telegram">
      <h5>Telegram</h5>
      <div class="footer_telegram_description"></div>
      Telegram is a cloud-based mobile and desktop messaging app with a focus on security and speed.
    </div>

    <div class="footer_column">
      <h5><a href="//telegram.org/faq">About</a></h5>
      <ul>
        <li><a href="//telegram.org/faq">FAQ</a></li>
        <li><a href="//telegram.org/blog">Blog</a></li>
        <li><a href="//telegram.org/jobs">Jobs</a></li>
      </ul>
    </div>
    <div class="footer_column">
      <h5><a href="//telegram.org/apps#mobile-apps">Mobile Apps</a></h5>
      <ul>
        <li><a href="//telegram.org/dl/ios">iPhone/iPad</a></li>
        <li><a href="//telegram.org/dl/android">Android</a></li>
        <li><a href="//telegram.org/dl/wp">Windows Phone</a></li>
      </ul>
    </div>
    <div class="footer_column">
      <h5><a href="//telegram.org/apps#desktop-apps">Desktop Apps</a></h5>
      <ul>
        <li><a href="//desktop.telegram.org/">PC/Mac/Linux</a></li>
        <li><a href="//macos.telegram.org/">macOS</a></li>
        <li><a href="//telegram.org/dl/web">Web-browser</a></li>
      </ul>
    </div>
    <div class="footer_column footer_column_platform">
      <h5><a href="/">Platform</a></h5>
      <ul>
        <li><a href="/api">API</a></li>
        <li><a href="//translations.telegram.org/">Translations</a></li>
        <li><a href="//instantview.telegram.org/">Instant View</a></li>
      </ul>
    </div>
  </div>
  <div class="footer_columns_wrap footer_mobile">
    <div class="footer_column">
      <h5><a href="//telegram.org/faq">About</a></h5>
    </div>
    <div class="footer_column">
      <h5><a href="//telegram.org/blog">Blog</a></h5>
    </div>
    <div class="footer_column">
      <h5><a href="//telegram.org/apps">Apps</a></h5>
    </div>
    <div class="footer_column">
      <h5><a href="/">Platform</a></h5>
    </div>
    <div class="footer_column">
      <h5><a href="https://twitter.com/telegram" target="_blank" data-track="Follow/Twitter" onclick="trackDlClick(this, event)">Twitter</a></h5>
    </div>
  </div>
</div>
    </div>
    <script src="/js/main.js?42"></script>
    <script src="/js/jquery.min.js?1"></script>
<script src="/js/bootstrap.min.js"></script>

    <script>window.initDevPageNav&&initDevPageNav();
backToTopInit("Go up");
removePreloadInit();
</script>
  </body>
</html>
<!-- page generated in 11.66ms -->
